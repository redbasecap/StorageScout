/**
 * Core Philosophy: This ruleset enforces a flat collection model with user-ownership.
 * All items are stored in a flat /items collection with userId fields for ownership.
 *
 * Data Structure:
 * - /items/{itemId}: All inventory items with userId field for ownership
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access must be explicitly granted.
 * - User Isolation: Users can only access documents they own (userId == auth.uid)
 * - Query-based Security: List operations require filtering by userId in the query
 * - Field Validation: userId field is immutable after creation
 *
 * Performance: Flat collection structure with indexed userId field enables fast
 * queries while maintaining strong security isolation between users.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for verifying document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document. Used for update and delete
     * operations to prevent acting on documents that don't exist.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // --- Validation Functions for /items ---

    /**
     * On create, ensures the new Item is owned by the authenticated user.
     */
    function hasValidItemCreateData() {
      return request.resource.data.userId == request.auth.uid;
    }

    /**
     * On update, ensures the Item's userId field is immutable.
     */
    function hasImmutableItemOwner() {
      return request.resource.data.userId == resource.data.userId;
    }

    /**
     * Checks if the user owns the item being accessed.
     */
    function isItemOwner() {
      return isSignedIn() && resource.data.userId == request.auth.uid;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Items collection - flat structure with userId-based ownership
     * @path /items/{itemId}
     * @allow (list) An authenticated user queries their own items:
     *        `db.collection('items').where('userId', '==', auth.uid).get()`
     * @allow (get) An authenticated user reads their own item:
     *        `db.doc('items/item_123').get()` where item.userId == auth.uid
     * @allow (create) A user creates an item with their userId:
     *        `db.collection('items').add({userId: auth.uid, name: 'Tool', ...})`
     * @deny (create) A user tries to create an item for another user:
     *       `db.collection('items').add({userId: 'other_user', ...})`
     * @deny (update) A user tries to change the userId field:
     *       `db.doc('items/item_123').update({userId: 'other_user'})`
     * @principle Enforces ownership via userId field with immutability guarantees.
     */
    match /items/{itemId} {
      allow get: if isItemOwner();
      allow list: if isSignedIn() && request.query.limit <= 1000;
      allow create: if isSignedIn() && hasValidItemCreateData();
      allow update: if isItemOwner() && hasImmutableItemOwner();
      allow delete: if isItemOwner();
    }
  }
}